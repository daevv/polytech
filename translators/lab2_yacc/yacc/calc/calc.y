%{
/*
 *  This impliments a simple calculator.
 *  expressions are formed from strings of binary-operators, unary-operators,
 *  atoms, and '(' expression ')'.
 *  binary operators:
 *     x + y   = addition
 *     x - y   = subtraction
 *     x * y   = multiplication
 *     x / y   = division
 *     x ^ y   = the y'th power of x
 *  unary operators:
 *     - x     = negative x
 *     sin x   = sine of x
 *     cos x   = cosine of x
 *     tan x   = tangent of x
 *     sqrt x  = square root of x
 *     exp  x  = the x'th power of e
 *     log  x  = logarithm of x (base 10)
 *  atoms:
 *     number = a floating point value.
 *     last    = the result of the previous expression.
 */
 
#include <stdio.h>
#include <math.h>

#define YYSTYPE double    
YYSTYPE last_value = 0;

//extern int yylex(void);
%}

/* 
 * Define the tokens produced by yylex()
 */
%token NUMBER  LAST HEX OCT
/*
 * The precedence and associativity are defined by these declarations.
 *
 * The lowest precedence are the functions.  These are right-associative,
 * thus  "sin 1 + 2" is interpreted as "sin(1+2)".
 *
 * The binary operators are left-associative, with the usual precedence
 * relationship. "1 - 2 - 3" is interpreted as "(1-2)-3)".
 *
 * NEGATIVE is a unary operator of high precedence.   This token is not
 * generated by the yylex(), but rather is used in a "precedence override"
 * rule to disambiguate it from the binary '-' operator.
 */
%right COS EXP SIN SQRT TAN
%left '+' '-'
%left '*' '/'
%left '^'
%right NEGATIVE

/*
 *  Begin specification of the parser.
 */
%%
/*
 * a 'list' may be empty, contain blank lines or expressions.
 * the final result of 'expressions' is printed and saved.
 */
list:
    | list '\n'
    | list expr '\n'        { printf("%.8g\n",last_value=$2); }
    | list HEX expr '\n'    { printf("0x%lx\n",
                                    (unsigned long)(last_value=$3)); }
    | list OCT expr '\n'    { printf("0%lo\n",
                                    (unsigned long)(last_value=$3)); }
    ;
/*
 * expressions are defined recursively, the precedence
 * and associativity rules disambiguate the grammar.
 */
expr
    :  NUMBER                   { $$ = $1;         }
    |  LAST                     { $$ = last_value; }
    |  '(' expr ')'             { $$ = $2;         }
    |  expr '+' expr            { $$ = $1 + $3;    }
    |  expr '-' expr            { $$ = $1 - $3;    }
    |  expr '*' expr            { $$ = $1 * $3;    }
    |  expr '/' expr            { $$ = $1 / $3;    }
    |  expr '^' expr            { $$ = pow($1,$3); }
    |  '-' expr  %prec NEGATIVE { $$ = - $2;       }
    |  COS   expr               { $$ = cos($2);    }
    |  EXP   expr               { $$ = exp($2);    }
    |  SIN   expr               { $$ = sin($2);    }
    |  SQRT  expr               { $$ = sqrt($2);   }
    |  TAN   expr               { $$ = tan($2);    }
    ;
%%
    
#include <stdlib.h>
#include <string.h>
/* #include <unistd.h>
*/

int lineno = 1;
int last_err_line;
int errcount;

#define MAX_ERR_PER_LINE  30

/*
 * yyerror() is called automatically by yyparse() when an 
 * error is detected in the input stream.   To avoid an avalanch of
 * errors, yyerror() only prints one message per line,
 * and if it sees too-many errors on a line, aborts the program.
 */
 
int yyerror(const char *s)
{
    if (lineno == last_err_line) {
        if (errcount++ >= MAX_ERR_PER_LINE) {
           fprintf(stderr,"line %d: too many errors to continue\n",
                lineno);
           exit(1);
        }
        return 0;
    }
    errcount = 0;
    fprintf(stderr,"line %d: %s\n",lineno,s);
    last_err_line = lineno;
    return 1;
}

main()
{
    int errcnt;
    while (yyparse()) errcnt++;
    return errcnt != 0;
}

